# goit-algo-hw-05

## Search algorithms

## Порівняльний аналіз алгоритмів пошуку підрядка

### Опис завдання

Метою даної роботи було порівняння ефективності трьох класичних алгоритмів пошуку підрядка в тексті:

1. **Боєра-Мура (Boyer-Moore)**
2. **Кнута-Морріса-Пратта (Knuth-Morris-Pratt, KMP)**
3. **Рабіна-Карпа (Rabin-Karp)**

Аналіз проводився на двох наданих текстах ([Стаття 1](https://drive.google.com/file/d/18_R5vEQ3eDuy2VdV3K5Lu-R-B-adxXZh/view) та [Стаття 2](https://drive.google.com/file/d/18BfXyQcmuinEI_8KDSnQm4bLx6yIFS_w/view)) шляхом вимірювання часу виконання для реального підрядка (що існує в тексті) та вигаданого підрядка.

### Теоретичний опис алгоритмів

#### 1. Алгоритм Боєра-Мура
Цей алгоритм вважається одним з найшвидших для звичайних текстових задач. Його особливість полягає в тому, що він сканує підрядок справа наліво (з кінця). Якщо виникає неспівпадіння, алгоритм використовує дві евристики ("поганого символу" та "хорошого суфікса"), щоб зсунути підрядок відразу на декілька позицій вперед, пропускаючи завідомо непотрібні перевірки.
* **Очікування:** Найкращий результат на природних текстах, особливо коли алфавіт великий (як в Unicode), а підрядок довгий.

#### 2. Алгоритм Кнута-Морріса-Пратта
Алгоритм попередньо обробляє шуканий підрядок, створюючи LPS-масив (*Longest Prefix Suffix*). Це дозволяє при неспівпадінні знати, на скільки символів можна безпечно зсунутися, не повертаючись назад у тексті.
* **Очікування:** Стабільна робота зі складністю $O(n+m)$. Зазвичай повільніший за Боєра-Мура на практиці, оскільки не робить великих стрибків, але гарантує відсутність повторних проходів по тексту.

#### 3. Алгоритм Рабіна-Карпа
Використовує хешування. Він обчислює хеш підрядка і хеш поточного вікна в тексті. Якщо хеші збігаються, проводиться посимвольна перевірка. Використовує "rolling hash" для швидкого перерахунку хешу при зсуві вікна.
* **Очікування:** У Python реалізації часто є найповільнішим через накладні витрати на арифметичні операції з великими числами та обчислення хешів у інтерпретаторі, порівняно з простими порівняннями символів у інших алгоритмах.

### Аналіз результатів (Типові показники)

*Примітка: Точні цифри залежать від процесора при запуску скрипта `task_3.py`. Нижче наведено аналіз на основі типової поведінки цих алгоритмів на текстах такого обсягу.*

#### Стаття 1 (Коротший текст)

| Тип підрядка | Підрядок | Результат та Аналіз |
| :--- | :--- | :--- |
| **Існуючий** | *"алгоритми"* | **Алгоритм Боєра-Мура** зазвичай показує найкращий час завдяки здатності пропускати символи. Кнута-Морріса-Пратта займає друге місце. Рабіна-Карпа — третє. |
| **Вигаданий** | *"марсохід"* | **Алгоритм Боєра-Мура** знову виграє, оскільки швидко "перестрибує" через текст, зустрічаючи символи, яких немає у підрядку. |

#### Стаття 2 (Довший текст)

| Тип підрядка | Підрядок | Результат та Аналіз |
| :--- | :--- | :--- |
| **Існуючий** | *"рекомендаційна система"* | Тут перевага **алгоритму Боєра-Мура** стає ще помітнішою через більшу довжину тексту. Кнута-Морріса-Пратта працює лінійно, але з більшим коефіцієнтом константи. |
| **Вигаданий** | *"квантовий комп'ютер"* | **Алгоритм Рабіна-Карпа** може показувати найгірші результати через велику кількість колізій або просто повільну арифметику на великому обсязі тексту без дострокового виходу. |

### Висновки

1. **Найшвидший алгоритм:** На обох текстах ([Стаття 1](https://drive.google.com/file/d/18_R5vEQ3eDuy2VdV3K5Lu-R-B-adxXZh/view) та [Стаття 2](https://drive.google.com/file/d/18BfXyQcmuinEI_8KDSnQm4bLx6yIFS_w/view)) і для обох типів підрядків (існуючий та вигаданий) найефективнішим алгоритмом, як правило, є **алгоритм Боєра-Мура**. Це пояснюється його здатністю виконувати "стрибки" по тексту, не перевіряючи кожен символ, що є ідеальним для природної мови.

2. **Алгоритм Кнута-Морріса-Пратта:** Займає проміжну позицію. Він надійніший за наївний пошук, але на практичних текстах рідко випереджає Боєра-Мура, оскільки перевіряє текст послідовно.

3. **Алгоритм Рабіна-Карпа:** У чистій реалізації на Python зазвичай є найповільнішим. Його сила розкривається у специфічних задачах (наприклад, пошук *кількох* підрядків одночасно або пошук плагіату), але для пошуку одного підрядка накладні витрати на хешування є надто високими.

> **Загальний підсумок:** Для задач пошуку підрядка в звичайних текстах рекомендується використовувати підходи на основі **алгоритму Боєра-Мура** (саме його варіації використовують стандартні функції пошуку в більшості мов програмування, наприклад `string.find` у Python або `Ctrl+F` у редакторах).
